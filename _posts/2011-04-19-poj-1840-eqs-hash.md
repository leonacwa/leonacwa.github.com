---
layout: post
title: poj 1840 Eqs (哈希查找)
category: acm
tags: [acm, poj, %e5%93%88%e5%b8%8c, %e6%9f%a5%e6%89%be, %e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a]
---

<pre>/* poj 1840 Eqs

  题意：给你系数a1, a2, a3, a4, a5, a1x1^3+ a2x2^3+ a3x3^3+ a4x4^3+ a5x5^3=0,
    限制 xi∈[-50,50], xi != 0, any i∈{1,2,3,4,5}.问你有多少种方法。

哈希的经典啊！
将等式分成左三个右两个，然后根据他们结果的绝对值进行取余数哈希。
用哈希存储右两个的结果，然后再枚举左三，看结果是否相同。
这样就过了，学习了这个思路，O(∩_∩)O哈哈~。
*/</pre>
<!--more-->
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
const int maxn = 5;
const int prime = 1280519;

struct Hash{
    int v;
    Hash* next;
};

Hash* hash[prime+1];
int c[maxn];
int x[maxn];
int ans;

int main()
{
    int t, p; 
    Hash * ph;
    for (int i = 0; i &lt; maxn; i++){
        scanf("%d", c+i);
    }
    memset(hash, 0, sizeof(hash));// printf("memsetn");

    for (x[0] = -50; x[0] &lt;= 50; x[0]++) if (x[0])
    for (x[1] = -50; x[1] &lt;= 50; x[1]++) if (x[1])
    {
        t = -(x[0]*x[0]*x[0]*c[0] + x[1]*x[1]*x[1]*c[1]);
        p = (t&gt;0?t:-t) % prime; //printf("%d  hash[%d]n", t, p);
        ph = new Hash;
        ph-&gt;v = t;
        ph-&gt;next = hash[p];
        hash[p] = ph;
    }
    ans = 0;
    for (x[2] = -50; x[2] &lt;= 50; x[2]++)if (x[2])
    for (x[3] = -50; x[3] &lt;= 50; x[3]++)if (x[3])
    for (x[4] = -50; x[4] &lt;= 50; x[4]++)if (x[4])
    {
        t = x[2]*x[2]*x[2]*c[2] + x[3]*x[3]*x[3]*c[3] + x[4]*x[4]*x[4]*c[4];
        p = (t&gt;0?t:-t) % prime; 
        ph = hash[p];
        while (ph){
            if (ph-&gt;v == t)
                ++ans;
            ph = ph-&gt;next;
        }
    }

    printf("%dn", ans);
    return 0;
}</pre>
